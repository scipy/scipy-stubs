from collections.abc import Sequence
from typing import Literal as L, Never, TypeAlias, overload
from typing_extensions import TypeVar, deprecated

import numpy as np
import numpy.typing as npt
import optype as op
import optype.numpy as onp
import optype.numpy.compat as npc

__all__ = [
    "block_diag",
    "circulant",
    "companion",
    "convolution_matrix",
    "dft",
    "fiedler",
    "fiedler_companion",
    "hadamard",
    "hankel",
    "helmert",
    "hilbert",
    "invhilbert",
    "invpascal",
    "leslie",
    "pascal",
    "toeplitz",
]

_ScalarT = TypeVar("_ScalarT", bound=np.generic, default=npc.number | np.bool_ | np.object_)

_Kind: TypeAlias = L["symmetric", "upper", "lower"]
_ConvMode: TypeAlias = L["valid", "same", "full"]

_Bool2D: TypeAlias = onp.Array2D[np.bool_]
_Bool3D: TypeAlias = onp.Array3D[np.bool_]
_BoolND: TypeAlias = onp.ArrayND[np.bool_]
_Int2D: TypeAlias = onp.Array2D[np.int_]
_Int3D: TypeAlias = onp.Array3D[np.int_]
_IntND: TypeAlias = onp.ArrayND[np.int_]
_Float2D: TypeAlias = onp.Array2D[np.float64]
_Float3D: TypeAlias = onp.Array3D[np.float64]
_FloatND: TypeAlias = onp.ArrayND[np.float64]
_Complex2D: TypeAlias = onp.Array2D[np.complex128]
_Complex3D: TypeAlias = onp.Array3D[np.complex128]
_ComplexND: TypeAlias = onp.ArrayND[np.complex128]

_To0D: TypeAlias = onp.CanArray0[_ScalarT]
_To1D: TypeAlias = Sequence[_To0D[_ScalarT]] | onp.CanArrayND[_ScalarT]
_ToStrict1D: TypeAlias = Sequence[_To0D[_ScalarT]] | onp.CanArray1D[_ScalarT]
_ToStrict2ND: TypeAlias = onp.SequenceND[_To1D[_ScalarT]] | onp.CanArrayND[_ScalarT, onp.AtLeast2D]
_ToND: TypeAlias = onp.SequenceND[_To0D[_ScalarT]] | onp.SequenceND[_To1D[_ScalarT]] | onp.CanArrayND[_ScalarT]

_JustAnyShape: TypeAlias = tuple[Never, Never, Never, Never]  # workaround for https://github.com/microsoft/pyright/issues/10232

###

#
@overload
def toeplitz(
    c: onp.ArrayND[_ScalarT, _JustAnyShape], r: onp.ToArrayND[_ScalarT, _ScalarT] | None = None
) -> onp.ArrayND[_ScalarT]: ...
@overload
def toeplitz(
    c: onp.ToArrayStrict1D[_ScalarT, _ScalarT], r: onp.ToArrayStrict1D[_ScalarT, _ScalarT] | None = None
) -> onp.Array2D[_ScalarT]: ...
@overload
def toeplitz(
    c: onp.ToArrayStrict2D[_ScalarT, _ScalarT], r: onp.ToArrayStrict2D[_ScalarT, _ScalarT] | None = None
) -> onp.Array3D[_ScalarT]: ...
@overload
def toeplitz(
    c: onp.ToArrayND[_ScalarT, _ScalarT], r: onp.ToArrayND[_ScalarT, _ScalarT] | None = None
) -> onp.ArrayND[_ScalarT]: ...
@overload
def toeplitz(c: list[int], r: onp.ToArrayStrict1D[int, npc.integer] | None = None) -> _Int2D: ...
@overload  # this strange order works around a false positive mypy `overload-overload` error
def toeplitz(c: list[bool], r: onp.ToBoolStrict1D | None = None) -> _Bool2D: ...
@overload
def toeplitz(c: list[float], r: onp.ToArrayStrict1D[float, npc.floating64] | None = None) -> _Float2D: ...
@overload
def toeplitz(c: list[complex], r: onp.ToArrayStrict1D[complex, npc.inexact64] | None = None) -> _Complex2D: ...
@overload
def toeplitz(c: Sequence[list[int]], r: onp.ToArrayStrict1D[int, npc.integer] | None = None) -> _Int3D: ...
@overload  # this strange order works around a false positive mypy `overload-overload` error
def toeplitz(c: Sequence[list[bool]], r: onp.ToBoolStrict1D | None = None) -> _Bool3D: ...
@overload
def toeplitz(c: Sequence[list[float]], r: onp.ToArrayStrict1D[float, npc.floating64] | None = None) -> _Float3D: ...
@overload
def toeplitz(c: Sequence[list[complex]], r: onp.ToArrayStrict1D[complex, npc.inexact64] | None = None) -> _Complex3D: ...
@overload
def toeplitz(c: onp.ToJustBoolND, r: onp.ToIntND | None = None) -> _BoolND: ...
@overload
def toeplitz(c: onp.ToJustInt64_ND, r: onp.ToIntND | None = None) -> _IntND: ...
@overload
def toeplitz(c: onp.ToJustFloat64_ND, r: onp.ToFloat64_ND | None = None) -> _FloatND: ...
@overload
def toeplitz(c: onp.ToJustComplex128_ND, r: onp.ToComplex128_ND | None = None) -> _ComplexND: ...

#
@overload
def circulant(c: onp.ToJustIntStrict1D) -> _Int2D: ...
@overload
def circulant(c: onp.ToJustIntND) -> _IntND: ...
@overload
def circulant(c: onp.ToJustFloatStrict1D) -> _Float2D: ...
@overload
def circulant(c: onp.ToJustFloatND) -> _FloatND: ...
@overload
def circulant(c: onp.ToJustComplexStrict1D) -> _Complex2D: ...
@overload
def circulant(c: onp.ToJustComplexND) -> _ComplexND: ...
@overload
def circulant(c: _ToStrict1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def circulant(c: _ToND[_ScalarT]) -> onp.ArrayND[_ScalarT]: ...

#
@overload
def companion(a: onp.ToJustIntStrict1D) -> _Int2D: ...
@overload
def companion(a: onp.ToJustIntND) -> _IntND: ...
@overload
def companion(a: onp.ToJustFloatStrict1D) -> _Float2D: ...
@overload
def companion(a: onp.ToJustFloatND) -> _FloatND: ...
@overload
def companion(a: onp.ToJustComplexStrict1D) -> _Complex2D: ...
@overload
def companion(a: onp.ToJustComplexND) -> _ComplexND: ...
@overload
def companion(a: _ToStrict1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def companion(a: _ToND[_ScalarT]) -> onp.ArrayND[_ScalarT]: ...

#
@overload
def convolution_matrix(a: onp.ToJustIntStrict1D, n: onp.ToInt, mode: _ConvMode = "full") -> _Int2D: ...
@overload
def convolution_matrix(a: onp.ToJustIntND, n: onp.ToInt, mode: _ConvMode = "full") -> _IntND: ...
@overload
def convolution_matrix(a: onp.ToJustFloatStrict1D, n: onp.ToInt, mode: _ConvMode = "full") -> _Float2D: ...
@overload
def convolution_matrix(a: onp.ToJustFloatND, n: onp.ToInt, mode: _ConvMode = "full") -> _FloatND: ...
@overload
def convolution_matrix(a: onp.ToJustComplexStrict1D, n: onp.ToInt, mode: _ConvMode = "full") -> _Complex2D: ...
@overload
def convolution_matrix(a: onp.ToJustComplexND, n: onp.ToInt, mode: _ConvMode = "full") -> _ComplexND: ...
@overload
def convolution_matrix(a: _ToStrict1D[_ScalarT], n: onp.ToInt, mode: _ConvMode = "full") -> onp.Array2D[_ScalarT]: ...
@overload
def convolution_matrix(a: _ToND[_ScalarT], n: onp.ToInt, mode: _ConvMode = "full") -> onp.ArrayND[_ScalarT]: ...

#
@overload
def fiedler(a: onp.ToJustIntStrict1D) -> _Int2D: ...
@overload
def fiedler(a: onp.ToJustIntND) -> _IntND: ...
@overload
def fiedler(a: onp.ToJustFloatStrict1D) -> _Float2D: ...
@overload
def fiedler(a: onp.ToJustFloatND) -> _FloatND: ...
@overload
def fiedler(a: onp.ToJustComplexStrict1D) -> _Complex2D: ...
@overload
def fiedler(a: onp.ToJustComplexND) -> _ComplexND: ...
@overload
def fiedler(a: _ToStrict1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def fiedler(a: _ToND[_ScalarT]) -> onp.ArrayND[_ScalarT]: ...

#
@overload
def fiedler_companion(a: onp.ToJustIntStrict1D) -> _Int2D: ...
@overload
def fiedler_companion(a: onp.ToJustIntND) -> _IntND: ...
@overload
def fiedler_companion(a: onp.ToJustFloatStrict1D) -> _Float2D: ...
@overload
def fiedler_companion(a: onp.ToJustFloatND) -> _FloatND: ...
@overload
def fiedler_companion(a: onp.ToJustComplexStrict1D) -> _Complex2D: ...
@overload
def fiedler_companion(a: onp.ToJustComplexND) -> _ComplexND: ...
@overload
def fiedler_companion(a: _ToStrict1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def fiedler_companion(a: _ToND[_ScalarT]) -> onp.ArrayND[_ScalarT]: ...

#
@overload
def leslie(f: onp.ToJustIntStrict1D, s: onp.ToJustIntStrict1D) -> _Int2D: ...
@overload
def leslie(f: onp.ToIntND, s: onp.ToJustIntND) -> _IntND: ...
@overload
def leslie(f: onp.ToJustIntND, s: onp.ToIntND) -> _IntND: ...
@overload
def leslie(f: onp.ToFloatStrict1D, s: onp.ToJustFloatStrict1D) -> _Float2D: ...
@overload
def leslie(f: onp.ToJustFloatStrict1D, s: onp.ToFloatStrict1D) -> _Float2D: ...
@overload
def leslie(f: onp.ToFloatND, s: onp.ToJustFloatND) -> _FloatND: ...
@overload
def leslie(f: onp.ToJustFloatND, s: onp.ToFloatND) -> _FloatND: ...
@overload
def leslie(f: onp.ToComplexStrict1D, s: onp.ToJustComplexStrict1D) -> _Complex2D: ...
@overload
def leslie(f: onp.ToJustComplexStrict1D, s: onp.ToComplexStrict1D) -> _Complex2D: ...
@overload
def leslie(f: onp.ToComplexND, s: onp.ToJustComplexND) -> _ComplexND: ...
@overload
def leslie(f: onp.ToJustComplexND, s: onp.ToComplexND) -> _ComplexND: ...
@overload
def leslie(f: _ToStrict1D[_ScalarT], s: _ToStrict1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def leslie(f: _ToND[_ScalarT], s: _ToND[_ScalarT]) -> onp.ArrayND[_ScalarT]: ...

#
@overload
def block_diag() -> _Float2D: ...  # shape=(1, 0)
@overload
def block_diag(arr0: onp.ToJustInt1D, /, *arrs: onp.ToJustInt1D) -> _Int2D: ...
@overload
def block_diag(arr0: onp.ToJustFloat1D, /, *arrs: onp.ToJustFloat1D) -> _Float2D: ...
@overload
def block_diag(arr0: onp.ToJustComplex1D, /, *arrs: onp.ToJustComplex1D) -> _Complex2D: ...
@overload
def block_diag(arr0: _To1D[_ScalarT], /, *arrs: _To1D[_ScalarT]) -> onp.Array2D[_ScalarT]: ...

#
def dft(n: onp.ToInt, scale: L["sqrtn", "n"] | None = None) -> _Complex2D: ...

#
@overload
def hadamard(n: onp.ToInt, dtype: type[op.JustInt]) -> _Int2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: type[op.JustFloat]) -> _Float2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: type[op.JustComplex]) -> _Complex2D: ...
@overload
def hadamard(n: onp.ToInt, dtype: onp.ToDType[_ScalarT]) -> onp.Array2D[_ScalarT]: ...
@overload
def hadamard(n: onp.ToInt, dtype: npt.DTypeLike = ...) -> onp.Array2D: ...

#
@overload
def hankel(c: onp.ToJustIntStrict1D, r: onp.ToJustIntStrict1D | None = None) -> _Int2D: ...
@overload
def hankel(c: onp.ToJustFloatStrict1D, r: onp.ToJustFloatStrict1D | None = None) -> _Float2D: ...
@overload
def hankel(c: onp.ToJustComplexStrict1D, r: onp.ToJustComplexStrict1D | None = None) -> _Complex2D: ...
@overload
def hankel(c: _ToStrict1D[_ScalarT], r: _ToStrict1D[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustIntND, r: onp.ToJustIntND | None = None) -> _Int2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustFloatND, r: onp.ToJustFloatND | None = None) -> _Float2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: onp.ToJustComplexND, r: onp.ToJustComplexND | None = None) -> _Complex2D: ...
@overload
@deprecated("Beginning in SciPy 1.19, multidimensional input will be treated as a batch, not `ravel`ed.")
def hankel(c: _ToStrict2ND[_ScalarT], r: _ToStrict2ND[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...
@overload
def hankel(c: _To1D[_ScalarT], r: _To1D[_ScalarT] | None = None) -> onp.Array2D[_ScalarT]: ...

#
def helmert(n: onp.ToInt, full: bool = False) -> _Float2D: ...

#
def hilbert(n: onp.ToInt) -> _Float2D: ...

#
@overload
def invhilbert(n: onp.ToInt, exact: L[False] = False) -> _Float2D: ...
@overload
def invhilbert(n: onp.ToInt, exact: L[True]) -> onp.Array2D[np.int64 | np.object_]: ...

#
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: L[True] = True) -> onp.Array2D[np.int64 | np.object_]: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind, exact: L[False]) -> _Float2D: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: L[False]) -> _Float2D: ...

#
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: L[True] = True) -> onp.Array2D[np.int64 | np.object_]: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind, exact: L[False]) -> _Float2D: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: L[False]) -> _Float2D: ...
